import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/auth";
import { prisma } from "@/lib/prisma";
import { randomUUID } from "crypto";

// GET /api/meetings - list current user's meetings (student view)
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    const userId = (session.user as any)?.id as string | undefined;
    if (!userId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

    const meetings = await prisma.meeting.findMany({
      where: { studentId: userId },
      orderBy: { startTime: "asc" },
    });
    return NextResponse.json({ meetings });
  } catch (err: any) {
    console.error("/api/meetings GET error", err);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

// POST /api/meetings - book a meeting
// body: { slotId, counsellorId, startTime, endTime, reason }
export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    const userId = (session.user as any)?.id as string | undefined;
    if (!userId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

    const body = await req.json();
    const { slotId, counsellorId, startTime, endTime, reason } = body as {
      slotId?: string;
      counsellorId?: string;
      startTime?: string;
      endTime?: string;
      reason?: string;
    };

    if (!counsellorId || !startTime || !endTime || !reason) {
      return NextResponse.json({ error: "counsellorId, startTime, endTime, reason required" }, { status: 400 });
    }

    const start = new Date(startTime);
    const end = new Date(endTime);
    if (!(start < end)) {
      return NextResponse.json({ error: "Invalid time range" }, { status: 400 });
    }

    // Optional: enforce slot exists and is not booked
    if (slotId) {
      const slot = await prisma.availability.findUnique({ where: { id: slotId } });
      if (!slot || slot.counsellorId !== counsellorId) {
        return NextResponse.json({ error: "Invalid slot" }, { status: 400 });
      }
      if (slot.isBooked) {
        return NextResponse.json({ error: "Slot already booked" }, { status: 409 });
      }
      // basic range check
      if (slot.startTime.getTime() !== start.getTime() || slot.endTime.getTime() !== end.getTime()) {
        return NextResponse.json({ error: "Slot time mismatch" }, { status: 400 });
      }
    }

    // Create meeting and mark slot booked if provided
    const created = await prisma.$transaction(async (tx) => {
      const meeting = await tx.meeting.create({
        data: {
          id: randomUUID(),
          studentId: userId,
          counsellorId,
          startTime: start,
          endTime: end,
          reason,
          status: "PENDING",
          // meetingLink to be generated by integration stub
        },
      });

      if (slotId) {
        await tx.availability.update({ where: { id: slotId }, data: { isBooked: true } });
      }

      return meeting;
    });

    // Stub: generate meeting link and send notifications in background later
    return NextResponse.json({ success: true, meeting: created });
  } catch (err: any) {
    console.error("/api/meetings POST error", err);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

